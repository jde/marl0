// services/product/utils.ts

import { db } from '@/lib/prisma'

/**
 * getAncestry
 * Recursively walks backward through activities to collect all ancestor entities
 * of a given entity ID. It follows the 'used' edges of activities where the
 * target entity was in the 'generated' set, building a provenance lineage chain.
 *
 * @param entityId The ID of the entity to trace from
 * @param depth How many levels deep to search (default: 3)
 * @returns An array of entity IDs representing the ancestry lineage
 */
export async function getAncestry(entityId: string, depth: number = 3): Promise<string[]> {
  const seen = new Set<string>()
  const result: string[] = []

  async function walk(id: string, d: number) {
    if (seen.has(id) || d > depth) return
    seen.add(id)
    result.push(id)

    const activity = await db.activity.findFirst({
      where: {
        generated: { some: { entityId: id } },
      },
      include: {
        used: true,
      },
    })

    if (!activity) return

    for (const input of activity.used) {
      await walk(input.entityId, d + 1)
    }
  }

  await walk(entityId, 0)
  return result
}

/**
 * getConsensusLabels
 * Computes the most supported (highest confidence-weighted) classification value
 * for each label name assigned to the given entity.
 *
 * @param entityId The entity whose classifications should be evaluated
 * @returns A dictionary of label name -> most confident value
 */
export async function getConsensusLabels(entityId: string): Promise<Record<string, string>> {
  const classifications = await db.classification.findMany({
    where: { entityId },
  })

  const map: Record<string, Record<string, number>> = {}

  for (const cls of classifications) {
    if (!map[cls.name]) map[cls.name] = {}
    map[cls.name][cls.value] = (map[cls.name][cls.value] || 0) + (cls.confidence ?? 1)
  }

  const consensus: Record<string, string> = {}
  for (const name of Object.keys(map)) {
    const values = Object.entries(map[name])
    values.sort((a, b) => b[1] - a[1])
    consensus[name] = values[0][0]
  }

  return consensus
}

/**
 * getClassificationDiffs
 * Compares two entities and returns an array of classification labels where
 * the values differ.
 *
 * @param entityA First entity ID
 * @param entityB Second entity ID
 * @returns An array of { name, a, b } for differing label values
 */
export async function getClassificationDiffs(entityA: string, entityB: string) {
  const [a, b] = await Promise.all([
    db.classification.findMany({ where: { entityId: entityA } }),
    db.classification.findMany({ where: { entityId: entityB } }),
  ])

  const result = []
  const aMap = new Map(a.map((c) => [c.name, c.value]))
  const bMap = new Map(b.map((c) => [c.name, c.value]))

  const allKeys = new Set([...aMap.keys(), ...bMap.keys()])

  for (const key of allKeys) {
    const va = aMap.get(key)
    const vb = bMap.get(key)
    if (va !== vb) {
      result.push({ name: key, a: va, b: vb })
    }
  }

  return result
}

/**
 * getForksFrom
 * Finds all entities that were generated by an activity that used the given entity.
 * This effectively finds siblings of the same transformation (forks).
 *
 * @param entityId The ID of the entity that served as input
 * @returns An array of entity records that were generated alongside or after
 */
export async function getForksFrom(entityId: string) {
  const activity = await db.activity.findFirst({
    where: {
      used: {
        some: { entityId },
      },
    },
    include: {
      generated: {
        include: {
          entity: true,
        },
      },
    },
  })

  if (!activity) return []

  return activity.generated.map((o) => o.entity)
}

/**
 * getLatestVersionsOf
 * Recursively walks forward through activities to find the latest descendants
 * of a given entity, stopping at terminal leaves in the lineage graph.
 *
 * @param entityId Starting entity ID
 * @returns An array of the most recent terminal entity IDs in the forward lineage
 */
export async function getLatestVersionsOf(entityId: string): Promise<string[]> {
  const seen = new Set<string>()
  const children: string[] = []

  async function walk(id: string) {
    if (seen.has(id)) return
    seen.add(id)

    const activity = await db.activity.findFirst({
      where: {
        used: { some: { entityId: id } },
      },
      include: {
        generated: true,
      },
    })

    if (!activity || activity.generated.length === 0) {
      children.push(id)
      return
    }

    for (const out of activity.generated) {
      await walk(out.entityId)
    }
  }

  await walk(entityId)
  return children
}
